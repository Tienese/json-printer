# 1.1.1.1 Coding Style & Rules

Standard: 1 Component | 1 Style | 1 Design | 1 Architecture

---

## 1. 1 Component: Single Responsibility
Components only render. Hooks handle logic.

- Logic Separation: Move all useEffect, useState (beyond simple UI toggles), and data fetching to custom hooks.
- Pure Rendering: Components should take props and return JSX. Minimize inline calculations.
- Rule of Three: Do not over-abstract. Copy/paste once is fine. Extract to a shared component only upon the third use.
- Instrumentation: Use devAssert.check() for complex state transitions to ensure data integrity during development.

## 2. 1 Style: Single Methodology
Tailwind exclusively. Print-first mindset.

- No Overrides: NEVER use CSS modules, styled-components, or inline style={{...}}. Use Tailwind classes only.
- Design Tokens: Use standard tailwind scales. Avoid hardcoded hex values; prefer semantic classes.
- Print Optimization (CRITICAL): 
  - All printable content must be Black & White (print:bg-white, print:text-black).
  - Maximize vertical space; use minimal margins (m-1, p-1) for print elements.
  - Use break-inside-avoid to prevent ugly cuts in printed worksheets.
- Static Aesthetics: No hover effects, no scale transitions, no flashy animations. The UI should feel solid and "printed" even on screen. No emojis in the final code or UI.

## 3. 1 Design: Unified UI System
Consistency over variety.

- Shared Primitives: Always use components from src/components/ui/ (Buttons, Inputs, Alerts).
- Navigation: Horizontal top navigation using the <Navbar /> component is the project standard.
- Visual Hierarchy: 
  - High contrast for readability.
  - Large typography for important data.
  - Minimalist borders instead of background colors for separation.

## 4. 1 Architecture: Structural Consistency
Predictable patterns across the stack.

- Feature-Based Folders: Group related files together (e.g., src/components/QuizBuilder/ contains the .tsx, .ts hook, and .types.ts).
- State Management: Use React Context for global-ish state. Avoid Redux/Zustand unless complexity demands it (unlikely for this project).
- Configurable Options: Any user-configurable option or system setting must be added to the /settings endpoint in the backend and exposed in the UI.
- Backend (Java 21): 
  - Use record for DTOs.
  - Use var for local variables.
  - Use RestClient (Java 21 style) for external APIs.
- Local Persistence: Use SQLite for persistence; localStorage for transient UI drafts.
- Observability: Maintain AI_TRACE JSON logging in the frontend to track user actions and state changes.

---

> [!IMPORTANT]
> Gold Rule: "1 Message = 1 Full Feature". Always batch Backend and Frontend changes together.
